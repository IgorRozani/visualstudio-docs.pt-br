---
title: "Avisos de design | Microsoft Docs"
ms.custom: ""
ms.date: "12/15/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "vs-devops-test"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "vs.codeanalysis.designrules"
helpviewer_keywords: 
  - "avisos de design"
  - "avisos da análise de código gerenciado, avisos de design"
  - "avisos, design"
ms.assetid: 34e65a18-560c-423f-814f-519089e318cf
caps.latest.revision: 25
caps.handback.revision: 25
author: "stevehoag"
ms.author: "shoag"
manager: "wpickett"
---
# Avisos de design
[!INCLUDE[vs2017banner](../code-quality/includes/vs2017banner.md)]

Os avisos de design dão suporte a aderência às diretrizes de design do.NET Framework.  
  
## Nesta seção  
  
|Regra|Descrição|  
|-----------|---------------|  
|[CA1000: não declarar membros estáticos em tipos genéricos](../code-quality/ca1000-do-not-declare-static-members-on-generic-types.md)|Quando um membro estático de um tipo genérico é chamado, o argumento de tipo deve ser especificado para o tipo.  Quando um membro da instância que não oferece suporte a inferência é chamado, o argumento de tipo deve ser especificado para o membro.  Nesses dois argumentos, a sintaxe para especificar o argumento de tipo é diferente e ofuscada facilmente.|  
|[CA1001: tipos que tenham campos descartáveis devem ser descartáveis](../Topic/CA1001:%20Types%20that%20own%20disposable%20fields%20should%20be%20disposable.md)|Uma classe declara e implementa um campo da instância que é um tipo de System.IDisposable e a classe não implementa IDisposable.  Uma classe que declara um campo IDisposable indiretamente possui um recurso não gerenciado e deve implementar a interface IDisposable.|  
|[CA1002: não expor listas genéricas](../Topic/CA1002:%20Do%20not%20expose%20generic%20lists.md)|System.Collections.Generic.List \(de\) \(T\) é uma coleção genérica\<\<\>\>que é criada para o desempenho, não herança.  Em virtude disso, a lista não contém nenhum membro virtuais.  As coleções genéricas que são criadas para a herança devem ser exposto em vez disso.|  
|[CA1003: usar instâncias do manipulador de eventos genéricos](../Topic/CA1003:%20Use%20generic%20event%20handler%20instances.md)|Um tipo contém um representante que retorna anulem, cuja assinatura contém dois parâmetros \(os primeiros um objeto e o segundo um tipo que é assinalável a EventArgs\), e o assembly que contém [!INCLUDE[dnprdnlong](../code-quality/includes/dnprdnlong_md.md)]de destino.|  
|[CA1004: os métodos genéricos devem fornecer o parâmetro de tipo](../code-quality/ca1004-generic-methods-should-provide-type-parameter.md)|A inferência é como o argumento de tipo de um método genérico é determinado pelo tipo de argumento transmitido ao método, em vez pela especificação explícita do argumento de tipo.  Para habilitar a inferência, a assinatura de parâmetro de um método genérico deve incluir um parâmetro que seja do mesmo tipo do parâmetro de tipo para o método.  Nesse caso, o argumento do tipo não precisa ser especificado.  Quando você usa a inferência para todos os parâmetros de tipo, a sintaxe para chamar métodos genéricos e não da instância é idêntica; isso simplifica a utilidade de métodos genéricos.|  
|[CA1005: evitar parâmetros excessivos em tipos genéricos](../code-quality/ca1005-avoid-excessive-parameters-on-generic-types.md)|Mais parâmetros de tipo que um tipo genérico contém, é mais difícil saber e lembrar\-se do que cada parâmetro de tipo representa.  Geralmente é óbvio com um parâmetro de tipo, como em ListT\<\>e, em determinados casos com dois parâmetros de tipo, como em\<DictionaryTKey, TValue\>.  No entanto, se houver mais de dois parâmetros de tipo existirem, dificuldade fica muito grande para a maioria dos usuários.|  
|[CA1006: não aninhar tipos genéricos em assinaturas de membro](../code-quality/ca1006-do-not-nest-generic-types-in-member-signatures.md)|Um argumento aninhado classificação é um argumento do tipo que também seja um tipo genérico.  Para chamar um membro cuja assinatura contém um argumento aninhado do tipo, o usuário deve criar uma instância de um tipo genérico e passar esse tipo para o construtor de um segundo tipo genérico.  O procedimento e a sintaxe necessários são complexos e devem ser evitados.|  
|[CA1007: usar genéricos quando apropriado](../code-quality/ca1007-use-generics-where-appropriate.md)|Um método externamente visível contém um parâmetro de referência do tipo System.Object.  O uso de um método genérico habilita todos os tipos, sujeito a restrições, para ser passado ao método sem primeira conversão o tipo para o tipo do parâmetro de referência.|  
|[CA1008: os enums devem ter valor zero](../code-quality/ca1008-enums-should-have-zero-value.md)|O valor padrão de uma enumeração não inicializadas, exatamente como outros tipos de valor, é zero.  Uma enumeração atribuída nonflags deve definir um membro usando o valor de zero de forma que o valor padrão é um valor válido da enumeração.  Se uma enumeração que tem o atributo de FlagsAttribute aplicado define um valor de zero membro, seu nome não deve ser “nenhum” para indicar que nenhum valor esteve definido na enumeração.|  
|[CA1009: declarar manipuladores de eventos corretamente](../code-quality/ca1009-declare-event-handlers-correctly.md)|Os métodos do manipulador de eventos usam dois parâmetros.  O primeiro é do tipo System.Object e é denominado “remetente”.  Este é o objeto que gerou o evento.  O segundo parâmetro é do tipo System.EventArgs e é denominado “e”.  Estes são os dados associados ao evento.  Os métodos do manipulador de eventos não devem retornar um valor; na linguagem de programação C\#, isso é indicado por nulo do tipo de retorno.|  
|[CA1010: as coleções devem implementar a interface genérica](../code-quality/ca1010-collections-should-implement-generic-interface.md)|Para ampliar a utilidade de uma coleção, implementar uma das interfaces genéricas da coleção.  A coleção pode ser usada para popular tipos genéricos da coleção.|  
|[CA1011: considere a passagem dos tipos base como parâmetros](../code-quality/ca1011-consider-passing-base-types-as-parameters.md)|Quando um tipo de base é especificado como um parâmetro em uma declaração do método, qualquer tipo derivado do tipo de base pode ser passado como o argumento correspondente ao método.  Se a funcionalidade extra fornecida pelo tipo de parâmetro derivada não for necessária, o uso do tipo de base habilita um uso mais amplo do método.|  
|[CA1012: tipos abstratos não devem ter construtores](../code-quality/ca1012-abstract-types-should-not-have-constructors.md)|Construtores em tipos abstratos podem ser chamados somente por tipos derivados.  Porque construtores públicos criam instâncias de um tipo, e você não pode criar instâncias de um tipo abstrato, um tipo abstrato que tem um construtor público é criado incorretamente.|  
|[CA1013: sobrecarregar igualdades de operador em add e subtract de sobrecarga](../code-quality/ca1013-overload-operator-equals-on-overloading-add-and-subtract.md)|Um público ou um tipo protegido implementam os operadores de adição ou subtração sem implementar o operador de igualdade.|  
|[CA1014: marcar assemblies com CLSCompliantAttribute](../code-quality/ca1014-mark-assemblies-with-clscompliantattribute.md)|CLS \(CLS\) define a nomeação de restrições, os tipos de dados, e as regras para que os assemblies devem se conformar se serão usadas pelas linguagens de programação.  O bom design exige que todos os assemblies indica explicitamente a conformidade de CLS usando CLSCompliantAttribute.  Se esse atributo não está presente em um assembly, o assembly não for compatível.|  
|[CA1016: marcar assemblies com AssemblyVersionAttribute](../code-quality/ca1016-mark-assemblies-with-assemblyversionattribute.md)|O .NET Framework usa o número de versão para identificar exclusivamente um assembly, e para associar digitar os assemblies altamente nomeados.  O número de versão é usado junto com a versão e a política do publicador.  Por padrão, os aplicativos são executados somente com a versão do assembly com que foram criados.|  
|[CA1017: marcar assemblies com ComVisibleAttribute](../code-quality/ca1017-mark-assemblies-with-comvisibleattribute.md)|ComVisibleAttribute determina como código gerenciado do acesso de clientes COM.  O bom design exige que os assemblies indica explicitamente a visibilidade da.  A visibilidade de COM pode ser definida para o assembly inteiro e então ser substituída para tipos e membros individuais do tipo.  Se esse atributo não estiver presente, o conteúdo do assembly são visíveis aos clientes COM.|  
|[CA1018: marcar atributos com AttributeUsageAttribute](../code-quality/ca1018-mark-attributes-with-attributeusageattribute.md)|Quando você define um atributo personalizado, o marcará usando AttributeUsageAttribute para indicar onde o código\-fonte no atributo personalizado pode ser aplicado.  O significado e o uso planejado de um atributo determinarão seus locais válidos em código.|  
|[CA1019: definir acessadores para argumentos de atributo](../code-quality/ca1019-define-accessors-for-attribute-arguments.md)|Os atributos podem definir argumentos obrigatórios que devem ser especificados quando você aplicar o atributo a um destino.  Eles também são conhecidos como argumentos posicionais porque são fornecidas para atribuir construtores como parâmetros posicionais.  Para cada argumento obrigatório, o atributo deve fornecer uma propriedade somente leitura correspondente de forma que o valor do argumento pode ser recuperado em tempo de execução.  Os atributos também podem definir argumentos opcionais, que também são conhecidos como argumentos nomeados.  Esses argumentos são fornecidos para atribuir por nome construtores e devem ter uma propriedade de leitura\/gravação correspondente.|  
|[CA1020: evitar namespaces com poucos tipos](../code-quality/ca1020-avoid-namespaces-with-few-types.md)|Verifique se cada um de seus namespaces tiver uma organização lógica, e que você tenha uma razão válido colocar em um namespace escassa preenchida.|  
|[CA1021: evitar parâmetros de saída](../code-quality/ca1021-avoid-out-parameters.md)|Passar tipos por referência \(usando out ou referência\) requer experiência com ponteiros, compreender como os tipos de valor e os tipos de referência são diferentes, e os métodos de manipulação com vários valores de retorno.  Além disso, a diferença entre de saída e os parâmetros de referência não são compreendidos muito.|  
|[CA1023: os indexadores não devem ser multidimensionais](../code-quality/ca1023-indexers-should-not-be-multidimensional.md)|Os indicadores \(ou seja, propriedades indexadas\) devem usar um único índice.  Os indicadores multidimensionais podem reduzir significativamente a usabilidade de biblioteca.|  
|[CA1024: usar propriedades quando apropriado](../code-quality/ca1024-use-properties-where-appropriate.md)|Um público ou um método protegido têm um nome que começa com “obtenham”, não têm nenhum parâmetro, e retornam um valor que não é uma matriz.  O método pode ser uma boa candidata a se tornar uma propriedade.|  
|[CA1025: substituir argumentos repetitivos por matriz de parâmetros](../Topic/CA1025:%20Replace%20repetitive%20arguments%20with%20params%20array.md)|Use uma matriz de parâmetro em vez dos argumentos repetidos quando o número exato de argumentos é desconhecido quando os argumentos e variáveis são do mesmo tipo ou podem ser passados que o mesmo tipo.|  
|[CA1026: parâmetros padrão não devem ser usados](../Topic/CA1026:%20Default%20parameters%20should%20not%20be%20used.md)|Os métodos que usam parâmetros padrão são permitidos no CLS; porém, o CLS permite que os compiladores ignorar os valores que são atribuídos a esses parâmetros.  Para manter o comportamento desejado pelas linguagens de programação, os métodos que usam parâmetros padrão devem ser substituídos por sobrecargas do método que fornecem os parâmetros padrão.|  
|[CA1027: marcar enums com FlagsAttribute](../code-quality/ca1027-mark-enums-with-flagsattribute.md)|Uma enumeração é um tipo de valor que define um conjunto de constantes nomeadas relacionadas.  Aplicar FlagsAttribute a uma enumeração quando as constantes nomeadas podem ser combinadas significativa.|  
|[CA1028: o armazenamento de enum deve ser Int32](../code-quality/ca1028-enum-storage-should-be-int32.md)|Uma enumeração é um tipo de valor que define um conjunto de constantes nomeadas relacionadas.  Por padrão, o tipo de dados System.Int32 é usada para armazenar o valor constante.  Embora você possa alterar esse tipo subjacente, não é necessário ou não é recomendado para a maioria dos cenários.|  
|[CA1030: usar eventos quando apropriado](../Topic/CA1030:%20Use%20events%20where%20appropriate.md)|Esta regra detecta os métodos que têm nomes que seriam usados normalmente para eventos.  Se um método é chamado em resposta a uma alteração de estado claramente definida, o método deve ser chamado por um manipulador de eventos.  Os objetos que chamam o método devem gerar eventos em vez de chamar o método diretamente.|  
|[CA1031: não capturar tipos de exceção gerais](../Topic/CA1031:%20Do%20not%20catch%20general%20exception%20types.md)|As exceções gerais não devem ser capturadas.  Capturar uma exceção mais específica, ou o lançar novamente a exceção geral como a última instrução no bloco de captura.|  
|[CA1032: implementar construtores de exceção padrão](../code-quality/ca1032-implement-standard-exception-constructors.md)|A falha ao fornecer o conjunto completo de construtores pode dificultar a tratar exceções corretamente.|  
|[CA1033: os métodos de interface devem ser chamáveis por tipos filho](../Topic/CA1033:%20Interface%20methods%20should%20be%20callable%20by%20child%20types.md)|Um tipo externamente visível unsealed fornece uma implementação explícita de método de uma interface pública e não fornece um método externamente visível de backup que tem o mesmo nome.|  
|[CA1034: os tipos aninhados não devem ser visíveis](../code-quality/ca1034-nested-types-should-not-be-visible.md)|Um tipo aninhado é um tipo que é declarada no escopo de outro tipo.  Os tipos aninhados são úteis para encapsular detalhes de implementação privados do tipo contentor.  Usados para essa finalidade, os tipos aninhados não devem ser externamente visíveis.|  
|[CA1035: as implementações de ICollection têm membros fortemente tipados](../code-quality/ca1035-icollection-implementations-have-strongly-typed-members.md)|Essa regra requer implementações de ICollection fornecer membros fortemente tipados de forma que usuários não sejam necessários lançar argumentos para o tipo de objeto quando usarem a funcionalidade fornecida pela interface.  Esta regra assumirá que o tipo que implementa ICollection é feito para gerenciar uma coleção de instâncias de um tipo que é mais segura que o objeto.|  
|[CA1036: substituir métodos em tipos comparáveis](../code-quality/ca1036-override-methods-on-comparable-types.md)|Um público ou um tipo protegido implementam a interface de System.IComparable.  Não substitui Object.Equals ou ele sobrecarregar o operador específico do idioma para igualdade, desigualdade, menor que, ou maior que.|  
|[CA1038: os enumeradores devem ser fortemente tipados](../code-quality/ca1038-enumerators-should-be-strongly-typed.md)|Essa regra requer implementações de IEnumerator fornecer também uma versão com rigidez da propriedade atual de forma que usuários não sejam necessários para converter o valor de retorno no tipo forte quando usarem a funcionalidade fornecida pela interface.|  
|[CA1039: as listas são fortemente tipadas](../code-quality/ca1039-lists-are-strongly-typed.md)|Essa regra requer IList fornecer implementações de membros fortemente tipados de forma que usuários não sejam necessários lançar argumentos para o tipo de System.Object quando usarem a funcionalidade fornecida pela interface.|  
|[CA1040: evitar interfaces vazias](../Topic/CA1040:%20Avoid%20empty%20interfaces.md)|As interfaces definem os membros que fornecem um contrato do comportamento ou de uso.  A funcionalidade descrita pela interface pode ser adotada por qualquer tipo, independentemente de onde o tipo é exibido na hierarquia de herança.  Um tipo implementa uma interface para fornecer implementações dos membros da interface.  Uma interface vazio não define nenhum membro; consequentemente, não define um contrato que pode ser implementado.|  
|[CA1041: fornecer mensagem ObsoleteAttribute](../Topic/CA1041:%20Provide%20ObsoleteAttribute%20message.md)|Um tipo ou membro são marcados com um atributo de System.ObsoleteAttribute que não tem sua propriedade de ObsoleteAttribute.Message especificada.  Quando um tipo ou membro que sejam marcados com ObsoleteAttribute são criados, a propriedade da mensagem do atributo é exibida, que fornece informações sobre o tipo de usuário ou o membro obsoleto.|  
|[CA1043: usar argumento integral ou da cadeia de caracteres para indexadores](../code-quality/ca1043-use-integral-or-string-argument-for-indexers.md)|Os indicadores \(ou seja, propriedades indexadas\) devem usar a base integral ou em tipos para o índice.  Esses tipos são normalmente usados para indexação estruturas de dados e aumentar a usabilidade de biblioteca.  O uso do tipo de objeto deve ser restrito 2 os casos onde o tipo específico ou integrante de cadeia de caracteres não pode ser especificado em tempo de design.|  
|[CA1044: as propriedades não devem ser somente leitura](../code-quality/ca1044-properties-should-not-be-write-only.md)|Embora seja aceitável e geralmente necessário ter uma propriedade somente leitura, as diretrizes de design proíbem o uso de propriedades somente gravação.  Isso é porque permitindo que um usuário defina um valor, e depois impedindo o usuário da exibição que avalia, o não fornece nenhuma segurança.  Além disso, sem acesso de leitura, o estado de objetos compartilhados não pode ser exibido, o que limita sua utilidade.|  
|[CA1045: não passar tipos por referência](../code-quality/ca1045-do-not-pass-types-by-reference.md)|Passar tipos por referência \(usando out ou referência\) requer experiência com ponteiros, compreender como os tipos de valor e os tipos de referência são diferentes, e os métodos de manipulação com vários valores de retorno.  Os arquitetos de biblioteca que criam para um público geral não devem esperar que os usuários dominar trabalhar com out ou parâmetros de referência.|  
|[CA1046: não sobrecarregar igualdades de operador em tipos de referência](../code-quality/ca1046-do-not-overload-operator-equals-on-reference-types.md)|Para tipos de referência, a implementação padrão do operador de igualdade está quase sempre correta.  Por padrão, duas referências são iguais apenas se apontam para o mesmo objeto.|  
|[CA1047: não declarar membros protegidos em tipos lacrados](../code-quality/ca1047-do-not-declare-protected-members-in-sealed-types.md)|Os tipos declaram membros protegidos herdar tipos de forma que possa acessar ou substituir o membro.  Por definição, os tipos selados não podem ser herdadas, o que significa que os métodos protegidos em tipos selados não podem ser chamados.|  
|[CA1048: não declarar membros virtuais em tipos lacrados](../code-quality/ca1048-do-not-declare-virtual-members-in-sealed-types.md)|Os tipos métodos declaram como virtual herdar tipos de forma que possa substituir a implementação do método virtual.  Por definição, um tipo selado não pode ser herdada.  Isso torna um método virtual em um tipo selado sem sentido.|  
|[CA1049: tipos que tenham recursos nativos devem ser descartáveis](../code-quality/ca1049-types-that-own-native-resources-should-be-disposable.md)|Tipos que atribui recursos não gerenciados deve implementar IDisposable para permitir chamadores para liberar os recursos sob demanda e para diminuir o tempo de vida de objetos que contêm os recursos.|  
|[CA1050: declarar tipos em namespaces](../code-quality/ca1050-declare-types-in-namespaces.md)|Os tipos são declarados nos namespaces para evitar colisões de nome e como uma forma de organizar relacionada em uma hierarquia de objetos.|  
|[CA1051: não declarar campos de instância visíveis](../code-quality/ca1051-do-not-declare-visible-instance-fields.md)|O principal uso de um campo deve ser um como detalhes de implementação.  Os campos devem ser privados ou internos e devem ser exposta usando propriedades.|  
|[CA1052: os tipos de suporte estático devem ser lacrados](../code-quality/ca1052-static-holder-types-should-be-sealed.md)|Um público ou um tipo protegido contêm apenas membros estáticos e não são declarados usando selado \(C\#\) ou modificador de NotInheritable \(Visual Basic\).  Um tipo que não é significado ser herdado deve ser marcado usando o modificador selado para evitar o seu uso como um tipo de base.|  
|[CA1053: os tipos de suporte estático não devem ter construtores](../code-quality/ca1053-static-holder-types-should-not-have-constructors.md)|Um público ou um tipo público aninhado declaram apenas membros estáticos e têm um construtor público ou protegido por padrão.  O construtor é desnecessária porque chamar membros estáticos não requer uma instância do tipo.  A sobrecarga de cadeia de caracteres deve chamar a sobrecarga do Uniform Resource Identifier \(URI\) usando o argumento de cadeia de caracteres para a segurança.|  
|[CA1054: os parâmetros de URI não devem ser cadeias de caracteres](../code-quality/ca1054-uri-parameters-should-not-be-strings.md)|Se um método usa uma representação de cadeia de caracteres de um URI, uma sobrecarga correspondente deve ser contanto que usa uma instância da classe do URI, que fornece estes serviços em um cofre e uma maneira segura.|  
|[CA1055: os valores de retorno de URI não devem ser cadeias de caracteres](../code-quality/ca1055-uri-return-values-should-not-be-strings.md)|Esta regra presume que o método retorna um URI.  Uma representação de cadeia de caracteres de um URI for susceptível a erros de análise e de codificação, e pode resultar em vulnerabilidades de segurança.  A classe de System.Uri fornece estes serviços em um cofre e uma maneira segura.|  
|[CA1056: as propriedades de URI não devem ser cadeias de caracteres](../code-quality/ca1056-uri-properties-should-not-be-strings.md)|Esta regra supõe que a propriedade representa um URI.  Uma representação de cadeia de caracteres de um URI for susceptível a erros de análise e de codificação, e pode resultar em vulnerabilidades de segurança.  A classe de System.Uri fornece estes serviços em um cofre e uma maneira segura.|  
|[CA1057: as sobrecargas de URI da cadeia de caracteres chamam sobrecargas System.Uri](../code-quality/ca1057-string-uri-overloads-call-system-uri-overloads.md)|Um tipo declara as sobrecargas do método que diferem apenas pela substituição de um parâmetro de cadeia de caracteres com um parâmetro de System.Uri.  A sobrecarga que usa o parâmetro de cadeia de caracteres não chama a sobrecarga que usa o parâmetro do URI.|  
|[CA1058: os tipos não devem estender determinados tipos base](../code-quality/ca1058-types-should-not-extend-certain-base-types.md)|Um tipo externamente visível estende determinados tipos de base.  Use uma das alternativas.|  
|[CA1059: os membros não devem expor determinados tipos concretos](../code-quality/ca1059-members-should-not-expose-certain-concrete-types.md)|Um tipo concreto é um tipo que tenha uma implementação completo e em virtude disso pode ser criada uma instância.  Para habilitar uso completo do membro, substitua o tipo concreto usando a interface sugerida.|  
|[CA1060: mover P\/Invokes para a classe NativeMethods](../code-quality/ca1060-move-p-invokes-to-nativemethods-class.md)|Os métodos de invocação da plataforma, como os marcados com <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> os métodos ou definido usando a palavra\-chave declarar em [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)], acessam o código não gerenciado.  Esses métodos devem ser da classe de NativeMethods, de SafeNativeMethods, ou de UnsafeNativeMethods.|  
|[CA1061: não ocultar métodos de classe base](../code-quality/ca1061-do-not-hide-base-class-methods.md)|Um método em um tipo de base é ocultado por um método idêntica nomeada em um tipo derivado, quando a assinatura do parâmetro de método derivada diferem apenas pelos tipos derivados mais fraco de correspondência na assinatura do parâmetro de método de base.|  
|[CA1062: validar argumentos de métodos públicos](../code-quality/ca1062-validate-arguments-of-public-methods.md)|Todos os argumentos de referência que são passados para os métodos externamente visíveis devem ser verificados em nulo.|  
|[CA1063: implementar IDisposable corretamente](../code-quality/ca1063-implement-idisposable-correctly.md)|Todos os tipos de IDisposable devem implementar o padrão de disposição corretamente.|  
|[CA1064: as exceções devem ser públicas](../Topic/CA1064:%20Exceptions%20should%20be%20public.md)|Uma exceção interna é visível somente dentro seu próprio escopo interno.  Depois que a exceção está fora do escopo interno, somente a exceção de base pode ser usada para capturar a exceção.  Se a exceção interna é herdada de <xref:System.Exception?displayProperty=fullName>, de <xref:System.SystemException?displayProperty=fullName>, ou de <xref:System.ApplicationException?displayProperty=fullName>, o código externo não terá informações suficientes para saber o que fazer com que a exceção.|  
|[CA1065: não acione exceções em locais inesperados](../code-quality/ca1065-do-not-raise-exceptions-in-unexpected-locations.md)|Um método que não é esperado que gera de exceções uma exceção.|  
|[CA2210: os assemblies devem ter nomes fortes válidos](../Topic/CA2210:%20Assemblies%20should%20have%20valid%20strong%20names.md)|O nome forte protege clientes unknowingly de carregar um assembly que é violados.  Os assemblies sem nomes fortes não devem ser implantados muito cenários limitados a parte externa.  Se você compartilhar ou distribui os assemblies que não estão assinados corretamente, o assembly pode ser violados, Common Language Runtime não pode carregar o assembly, ou o usuário talvez precise desabilitar a verificação em seu computador.|